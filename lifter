#!/usr/bin/env python
# -*- indent-tabs-mode: t -*-


import sys, os, signal, time
from displayer import MapDrawer
from mapupdater import world
from controler import controler, kcontroler

def reset_tty_and_exit():
	termios.tcsetattr(fd, termios.TCSANOW, old_settings)
	os.system("reset")
	sys.exit(0)

def handler(signum, frame):
	print 'Signal ', signum, 'catched'
	if signum == signal.SIGINT:
		print 'SIGINT, we exit !'
		cont.set_movement("A")
		time.sleep(2)
		reset_tty_and_exit()
	if signum == signal.SIGTERM:
		print 'SIGTERM, we exit as well, did we miss SIGINT ??'
		cont.set_movement("A")
		time.sleep(2)
		reset_tty_and_exit()

signal.signal(signal.SIGINT, handler)
signal.signal(signal.SIGTERM, handler)


lambda_map = [[]]

if len(sys.argv) == 1:
	print "usage: ", sys.argv[0], " <map_file_map>"
	exit(1)

with open(sys.argv[1]) as m:
	for line in m:
		for c in line:
			if c == '\n':
				lambda_map.insert(0,[])
				continue
			lambda_map[0].append(c)

lambda_map.pop(0)
#padding with ' '
maxcol = max([len(lambda_map[i]) for i,v in enumerate(lambda_map)])
print maxcol
for i, val in enumerate(lambda_map):
	if len(lambda_map[i]) != maxcol:
		val.extend([' ' for padder in range(maxcol - len(val)+1)])
	

print "Map displayed by Displayer"
displayer=MapDrawer(lambda_map)
#Now lambda_map is "reindexed"
lambda_map=displayer.getmap()

displayer.draw()

world = world(lambda_map)
control = kcontroler(lambda_map)
# We set terminal in raw mode to catch single key events
# This allows stdin.read() to be unbuffered
# which means read(1) will return, even without any \n

while 1:

	world.set_movement(control.get_next())
	displayer.draw()
